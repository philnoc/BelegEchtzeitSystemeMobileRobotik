#!/usr/bin/env python3
import time
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from builtin_interfaces.msg import Time
from geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped
from irobot_create_msgs.action import Undock
from nav2_msgs.srv import LoadMap
from nav2_msgs.action import NavigateToPose


# === HIER anpassen: Pfad zu deiner gespeicherten Karten-YAML ===
MAP_YAML = "/home/leobots/Desktop/Phil_MB_prak"   # z.B. "/home/user/maps/office.yaml"

# === Deine Ziel- und Initial-Pose (aus deiner Nachricht) ===
GOAL = {
    "x": -2.110913879355672,
    "y":  0.7525358957286679,
    "z":  0.0,
    "qx": 0.0, "qy": 0.0, "qz": 0.913633040759143, "qw": 0.4065398711482088,
}
INITIAL = {
    "x": -0.21431803448706277,
    "y": -0.5471780981410362,
    "z":  0.0,
    "qx": 0.0, "qy": 0.0, "qz": -0.9812881052087776, "qw": 0.19254520138338138,
    # Optionale Kovarianz ‚Äì solide, nicht zu eng:
    "cov": [0.25,0,0,0,0,0,
            0,0.25,0,0,0,0,
            0,0,1e6,0,0,0,
            0,0,0,1e6,0,0,
            0,0,0,0,1e6,0,
            0,0,0,0,0,0.25],
}


class UndockLoadMapInitNav(Node):
    def __init__(self):
        super().__init__('undock_loadmap_initnav')

        # Clients/Publisher
        self.undock_client = ActionClient(self, Undock, '/undock')
        self.map_client    = self.create_client(LoadMap, '/map_server/load_map')
        self.nav_client    = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        self.initpose_pub  = self.create_publisher(PoseWithCovarianceStamped, '/initialpose', 10)

    # ---- Hilfsfunktionen ----
    def _stamp_now(self) -> Time:
        now = self.get_clock().now().to_msg()
        return now

    def _make_pose_stamped(self, x, y, z, qx, qy, qz, qw, frame='map') -> PoseStamped:
        ps = PoseStamped()
        ps.header.stamp = self._stamp_now()
        ps.header.frame_id = frame
        ps.pose.position.x = float(x)
        ps.pose.position.y = float(y)
        ps.pose.position.z = float(z)
        ps.pose.orientation.x = float(qx)
        ps.pose.orientation.y = float(qy)
        ps.pose.orientation.z = float(qz)
        ps.pose.orientation.w = float(qw)
        return ps

    # ---- Pipeline-Schritte ----
    def do_undock(self) -> bool:
        self.get_logger().info('Warte auf /undock Action-Server‚Ä¶')
        self.undock_client.wait_for_server()

        goal = Undock.Goal()  # keine Felder n√∂tig
        send_fut = self.undock_client.send_goal_async(goal)
        rclpy.spin_until_future_complete(self, send_fut)
        goal_handle = send_fut.result()
        if not goal_handle or not goal_handle.accepted:
            self.get_logger().error('Undock-Goal abgelehnt.')
            return False

        self.get_logger().info('Undock-Goal akzeptiert ‚Äì warte auf Result‚Ä¶')
        res_fut = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, res_fut)
        result = res_fut.result().result
        # Beim Create3 liefert Result den Dock-Status (is_docked), kein "success".
        is_docked = getattr(result, 'is_docked', None)
        self.get_logger().info(f'Undock beendet. is_docked={is_docked}')
        return (is_docked is False) or (is_docked is None)

    def load_map(self, yaml_path: str) -> bool:
        self.get_logger().info(f"Warte auf Service /map_server/load_map‚Ä¶")
        if not self.map_client.wait_for_service(timeout_sec=10.0):
            self.get_logger().error('Map-Server nicht verf√ºgbar. L√§uft Nav2/map_server?')
            return False
        req = LoadMap.Request()
        req.map_url = yaml_path
        fut = self.map_client.call_async(req)
        rclpy.spin_until_future_complete(self, fut)
        resp = fut.result()
        ok = bool(resp and getattr(resp, 'result', False))
        self.get_logger().info(f'Map laden: {"OK" if ok else "FEHLER"}')
        return ok

    def publish_initialpose(self, init: dict):
        msg = PoseWithCovarianceStamped()
        msg.header.stamp = self._stamp_now()
        msg.header.frame_id = 'map'
        msg.pose.pose.position.x = float(init["x"])
        msg.pose.pose.position.y = float(init["y"])
        msg.pose.pose.position.z = float(init["z"])
        msg.pose.pose.orientation.x = float(init["qx"])
        msg.pose.pose.orientation.y = float(init["qy"])
        msg.pose.pose.orientation.z = float(init["qz"])
        msg.pose.pose.orientation.w = float(init["qw"])
        if "cov" in init:
            msg.pose.covariance = init["cov"]

        # Mehrfach publizieren (AMCL lauscht nicht immer genau im selben Moment)
        for i in range(3):
            self.initpose_pub.publish(msg)
            time.sleep(0.1)
        self.get_logger().info('Initialpose ver√∂ffentlicht.')

    def navigate_to(self, goal: dict) -> bool:
        self.get_logger().info('Warte auf navigate_to_pose Action-Server‚Ä¶')
        self.nav_client.wait_for_server()

        nav_goal = NavigateToPose.Goal()
        nav_goal.pose = self._make_pose_stamped(
            goal["x"], goal["y"], goal["z"], goal["qx"], goal["qy"], goal["qz"], goal["qw"], frame='map'
        )
        send_fut = self.nav_client.send_goal_async(nav_goal)
        rclpy.spin_until_future_complete(self, send_fut)
        handle = send_fut.result()
        if not handle or not handle.accepted:
            self.get_logger().error('NavigateToPose-Goal abgelehnt.')
            return False

        self.get_logger().info('Goal akzeptiert ‚Äì warte auf Navigationsergebnis‚Ä¶')
        res_fut = handle.get_result_async()
        rclpy.spin_until_future_complete(self, res_fut)
        res = res_fut.result()
        # res.status (uint8) folgt den rclcpp_action-Statuscodes; 4 == SUCCEEDED
        status = getattr(res, 'status', 0)
        self.get_logger().info(f'Navigation Status={status} (4=SUCCEEDED)')
        return status == 4

    # ---- Pipeline orchestration ----
    def run_pipeline(self):
        if not self.do_undock():
            self.get_logger().error('Undock fehlgeschlagen ‚Äì breche ab.')
            return
        if not self.load_map(MAP_YAML):
            self.get_logger().error('Map konnte nicht geladen werden ‚Äì breche ab.')
            return
        # kurze Wartezeit, damit map_server/AMCL stabil sind
        time.sleep(0.5)
        self.publish_initialpose(INITIAL)
        # AMCL etwas Zeit geben, die Pose zu √ºbernehmen
        time.sleep(0.5)
        ok = self.navigate_to(GOAL)
        if ok:
            self.get_logger().info('üéâ Ziel erfolgreich erreicht.')
        else:
            self.get_logger().warn('‚ö†Ô∏è Navigation nicht erfolgreich.')


def main():
    rclpy.init()
    node = UndockLoadMapInitNav()
    try:
        node.run_pipeline()
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()

