#!/usr/bin/env python3
import math
import time
from enum import Enum

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.qos import qos_profile_sensor_data

from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Bool

from irobot_create_msgs.action import Undock, Dock
from irobot_create_msgs.msg import HazardDetectionVector, AudioNote, AudioNoteVector
from builtin_interfaces.msg import Duration


def yaw_from_quat(q):
    siny_cosp = 2.0 * (q.w * q.z + q.x * q.y)
    cosy_cosp = 1.0 - 2.0 * (q.y * q.y + q.z * q.z)
    return math.atan2(siny_cosp, cosy_cosp)

class Phase(Enum):
    UNDOCK = 0
    PLAY_MARIO = 1
    ROTATE_45 = 2
    DRIVE_TO_BUMPER = 3
    BACKUP_10CM = 4
    ROTATE_180 = 5
    DRIVE_TO_30CM = 6
    STOP_AUDIO_AND_DOCK = 7
    DONE = 8

class BumperScanRoutine(Node):
    def __init__(self):
        super().__init__('bumper_scan_routine')

        # --- Parameter ---
        self.declare_parameter('cmd_vel_topic', '/cmd_vel')
        self.declare_parameter('odom_topic', '/odom')
        self.declare_parameter('scan_topic', '/scan')
        self.declare_parameter('hazard_topic', '/hazard_detection')
        self.declare_parameter('audio_topic', '/cmd_audio')
        self.declare_parameter('undock_action', '/undock')
        self.declare_parameter('dock_action', '/dock')

        self.declare_parameter('forward_speed', 0.15)
        self.declare_parameter('backward_speed', -0.12)
        self.declare_parameter('angular_speed_max', 0.6)
        self.declare_parameter('angle_tolerance_deg', 3.0)
        self.declare_parameter('backup_distance_m', 0.10)
        self.declare_parameter('lidar_stop_m', 0.30)

        # --- Pub/Sub/Actions ---
        self.cmd_pub = self.create_publisher(
            Twist, self.get_parameter('cmd_vel_topic').value, 10)

        self.audio_pub = self.create_publisher(
            AudioNoteVector, self.get_parameter('audio_topic').value, 10)

        # WICHTIG: Sensor-QoS (BestEffort) für odom/scan/hazard
        self.odom_sub = self.create_subscription(
            Odometry, self.get_parameter('odom_topic').value, self.odom_cb, qos_profile_sensor_data)

        self.scan_sub = self.create_subscription(
            LaserScan, self.get_parameter('scan_topic').value, self.scan_cb, qos_profile_sensor_data)

        self.hazard_sub = self.create_subscription(
            HazardDetectionVector, self.get_parameter('hazard_topic').value, self.hazard_cb, qos_profile_sensor_data)

        self.undock_client = ActionClient(self, Undock, self.get_parameter('undock_action').value)
        self.dock_client   = ActionClient(self, Dock,   self.get_parameter('dock_action').value)

        # --- State ---
        self.phase = Phase.UNDOCK
        self.phase_started = self.get_clock().now()
        self.current_yaw = None
        self.current_xy = None
        self.yaw_target = None
        self.pose0 = None
        self.bumped = False
        self.front_dist = math.inf

        self.timer = self.create_timer(0.1, self.step)
        self.get_logger().info('Sequenz gestartet.')
        self.start_undock()

    # ---------- Callbacks ----------
    def odom_cb(self, msg: Odometry):
        self.current_yaw = yaw_from_quat(msg.pose.pose.orientation)
        self.current_xy = (msg.pose.pose.position.x, msg.pose.pose.position.y)

    def scan_cb(self, msg: LaserScan):
        if not msg.ranges:
            self.front_dist = math.inf
            return
        angle_min, angle_inc = msg.angle_min, msg.angle_increment
        n = len(msg.ranges)
        def idx(rad):
            i = int(round((rad - angle_min) / angle_inc))
            return max(0, min(n-1, i))
        i0, i1 = idx(-math.radians(10)), idx(+math.radians(10))
        if i0 <= i1:
            seg = msg.ranges[i0:i1+1]
        else:
            seg = msg.ranges[i0:] + msg.ranges[:i1+1]
        vals = [r for r in seg if math.isfinite(r)]
        self.front_dist = min(vals) if vals else math.inf

    def hazard_cb(self, msg: HazardDetectionVector):
        if msg.detections:
            self.bumped = True

    # ---------- Utils ----------
    def stop(self):
        self.cmd_pub.publish(Twist())

    def elapsed(self):
        return (self.get_clock().now() - self.phase_started).nanoseconds * 1e-9

    def switch(self, new_phase: Phase):
        self.stop()
        self.phase = new_phase
        self.phase_started = self.get_clock().now()
        self.get_logger().info(f'→ Phase: {self.phase.name}')
        if new_phase == Phase.PLAY_MARIO:
            self.play_mario()
            self.create_timer(1.0, lambda: self.switch(Phase.ROTATE_45))
        elif new_phase == Phase.ROTATE_45:
            self.prepare_rotation(-45.0)
        elif new_phase == Phase.BACKUP_10CM:
            self.pose0 = self.current_xy
        elif new_phase == Phase.ROTATE_180:
            self.prepare_rotation(180.0, relative=True)
        elif new_phase == Phase.STOP_AUDIO_AND_DOCK:
            self.stop_audio()
            self.start_dock()

    def prepare_rotation(self, deg: float, relative: bool=True):
        if self.current_yaw is None:
            return
        tgt = self.current_yaw + math.radians(deg) if relative else math.radians(deg)
        self.yaw_target = math.atan2(math.sin(tgt), math.cos(tgt))

    def angle_err(self, cur, target):
        return math.atan2(math.sin(target-cur), math.cos(target-cur))

    def dist_since(self, start_xy):
        if not start_xy or not self.current_xy:
            return 0.0
        x0,y0 = start_xy; x,y = self.current_xy
        return math.hypot(x-x0, y-y0)

    # ---------- Audio ----------
    def play_mario(self):
        # Frequenzen jetzt als INT, Pause als 0
        notes = [
            (2637, 0.25), (2093, 0.25), (3136, 0.35),
            (0,    0.05),
            (3136, 0.25), (3951, 0.25), (2637, 0.35),
        ]
        self.publish_notes(notes, append=False)

    def start_indy(self):
        motif = [
            (330, 200e-3), (392, 200e-3), (494, 250e-3), (523, 150e-3),
            (587, 250e-3), (659, 350e-3), (0,   100e-3),
        ]
        seq = motif * 6
        self.publish_notes(seq, append=False)

    def stop_audio(self):
        vec = AudioNoteVector()
        vec.append = False
        vec.notes = []
        self.audio_pub.publish(vec)

    def publish_notes(self, notes, append=False):
        vec = AudioNoteVector()
        vec.append = bool(append)
        for f, secs in notes:
            n = AudioNote()
            n.frequency = int(f)               # <-- WICHTIG: int, nicht float
            s = float(secs)
            sec = int(s)
            nsec = int((s - sec) * 1e9)
            n.max_runtime = Duration(sec=sec, nanosec=nsec)
            vec.notes.append(n)
        self.audio_pub.publish(vec)

    # ---------- Actions ----------
    def start_undock(self):
        self.get_logger().info('Warte auf /undock…')
        self.undock_client.wait_for_server()
        goal = Undock.Goal()
        fut = self.undock_client.send_goal_async(goal)
        fut.add_done_callback(self._on_undock_sent)

    def _on_undock_sent(self, fut):
        h = fut.result()
        if not h or not h.accepted:
            self.get_logger().error('Undock abgelehnt.')
            self.phase = Phase.DONE
            return
        self.get_logger().info('Undock akzeptiert – warte auf Result…')
        res_fut = h.get_result_async()
        res_fut.add_done_callback(self._on_undock_result)

    def _on_undock_result(self, fut):
        try:
            res = fut.result().result
            self.get_logger().info(f'Undock beendet. is_docked={getattr(res,"is_docked",None)}')
        except Exception as e:
            self.get_logger().warn(f'Undock Result: {e}')
        self.switch(Phase.PLAY_MARIO)

    def start_dock(self):
        self.get_logger().info('Warte auf /dock…')
        self.dock_client.wait_for_server()
        fut = self.dock_client.send_goal_async(Dock.Goal())
        fut.add_done_callback(self._on_dock_sent)

    def _on_dock_sent(self, fut):
        h = fut.result()
        if not h or not h.accepted:
            self.get_logger().error('Dock abgelehnt.')
            self.phase = Phase.DONE
            return
        self.get_logger().info('Dock akzeptiert – warte auf Result…')
        res_fut = h.get_result_async()
        res_fut.add_done_callback(self._on_dock_result)

    def _on_dock_result(self, fut):
        try:
            res = fut.result().result
            self.get_logger().info(f'Dock beendet. is_docked={getattr(res,"is_docked",None)}')
        except Exception as e:
            self.get_logger().warn(f'Dock Result: {e}')
        self.switch(Phase.DONE)

    # ---------- Haupt-Loop ----------
    def step(self):
        ang_max = float(self.get_parameter('angular_speed_max').value)
        tol = math.radians(float(self.get_parameter('angle_tolerance_deg').value))
        v_fwd = float(self.get_parameter('forward_speed').value)
        v_back = float(self.get_parameter('backward_speed').value)
        lidar_stop = float(self.get_parameter('lidar_stop_m').value)

        # Rotationen
        if self.phase in (Phase.ROTATE_45, Phase.ROTATE_180):
            if self.current_yaw is None or self.yaw_target is None:
                return
            err = self.angle_err(self.current_yaw, self.yaw_target)
            cmd = Twist()
            if abs(err) > tol:
                cmd.angular.z = max(-ang_max, min(ang_max, 1.5 * err))
                self.cmd_pub.publish(cmd)
            else:
                self.stop()
                if self.phase == Phase.ROTATE_45:
                    self.start_indy()
                    self.bumped = False
                    self.switch(Phase.DRIVE_TO_BUMPER)
                else:
                    self.switch(Phase.DRIVE_TO_30CM)
            if self.elapsed() > 12.0:
                self.get_logger().warn('Rotations-Timeout, fahre fort.')
                self.stop()
                if self.phase == Phase.ROTATE_45:
                    self.start_indy()
                    self.switch(Phase.DRIVE_TO_BUMPER)
                else:
                    self.switch(Phase.DRIVE_TO_30CM)
            return

        # Fahrt bis Bumper
        if self.phase == Phase.DRIVE_TO_BUMPER:
            if self.bumped:
                self.stop()
                self.switch(Phase.BACKUP_10CM)
                return
            cmd = Twist(); cmd.linear.x = v_fwd
            self.cmd_pub.publish(cmd)
            if self.elapsed() > 25.0:
                self.get_logger().warn('Kein Bumper in 25s – fahre trotzdem weiter.')
                self.stop()
                self.switch(Phase.BACKUP_10CM)

        # 10 cm rückwärts (per Odometrie)
        elif self.phase == Phase.BACKUP_10CM:
            if self.pose0 is None or not self.current_xy:
                self.pose0 = self.current_xy
                return
            if self.dist_since(self.pose0) >= float(self.get_parameter('backup_distance_m').value):
                self.stop()
                self.switch(Phase.ROTATE_180)
            else:
                cmd = Twist(); cmd.linear.x = v_back
                self.cmd_pub.publish(cmd)
            if self.elapsed() > 10.0:
                self.get_logger().warn('Backup-Timeout – 180°-Drehung.')
                self.stop()
                self.switch(Phase.ROTATE_180)

        # Fahrt bis LiDAR <= 0.30 m
        elif self.phase == Phase.DRIVE_TO_30CM:
            if self.front_dist <= lidar_stop:
                self.stop()
                self.switch(Phase.STOP_AUDIO_AND_DOCK)
            else:
                cmd = Twist(); cmd.linear.x = v_fwd
                self.cmd_pub.publish(cmd)
            if self.elapsed() > 25.0:
                self.get_logger().warn('LiDAR-Timeout – Docking trotzdem.')
                self.stop()
                self.switch(Phase.STOP_AUDIO_AND_DOCK)

        elif self.phase == Phase.STOP_AUDIO_AND_DOCK:
            pass

        elif self.phase == Phase.DONE:
            self.stop()
            if rclpy.ok():
                self.get_logger().info('Sequenz abgeschlossen.')
                rclpy.shutdown()


def main():
    rclpy.init()
    node = BumperScanRoutine()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        if rclpy.ok():
            rclpy.shutdown()


if __name__ == '__main__':
    main()

